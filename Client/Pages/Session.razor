@page "/game/{SessionId}"
@using Microsoft.AspNetCore.SignalR.Client
@using System.IO.Compression
@using System.Text
@using WordleOff.Shared
@inject NavigationManager NavigationManager
@inject IJSRuntime jsRuntime
@implements IAsyncDisposable

<div style=@($"display: {(sessionInitialized ? "none" : "")}")>
  Your Name:
  <input @bind="playerName" disabled="@(!IsConnected || IsGameInProgress)" maxlength="20"/>
  <button @onclick="JoinSession" disabled="@(!IsConnected || IsGameInProgress)">Join</button>
  <div>
    @joinErrorMessage
  </div>
</div>
<div
  style=@($"display: {(sessionInitialized ? "" : "none")};")
  class="game"
  @onkeydown="@KeyDown"
  tabindex="0"
>
  <div>
    @RenderPlayerDataTable!((playerName, guess, correctAnswer!, playerDataDictionary))
  </div>
  <br/>
  <div class="div-center">
    @submitError
    @holdMessage
  </div>
  <br/><br/>
  <div class="div-center">
    <div class="reset-row" @onclick="NewGame">
      <div class=@($"guess-tile guess-tile-small {@resetButtonClass}")>R</div>
      <div class=@($"guess-tile guess-tile-small {@resetButtonClass}")>E</div>
      <div class=@($"guess-tile guess-tile-small {@resetButtonClass}")>S</div>
      <div class=@($"guess-tile guess-tile-small {@resetButtonClass}")>E</div>
      <div class=@($"guess-tile guess-tile-small {@resetButtonClass}")>T</div>
    </div>
  </div>
</div>


@code {
  [Parameter]
  public String SessionId { get; set; } = "";

  private String playerName = "";
  private String joinErrorMessage = "";
  private String guess = "";
  private String submitError = "";
    private String holdMessage = "";
  private HubConnection? hubConnection;
  private Boolean canSubmitNewGuess;
  private Boolean sessionInitialized = false;
  private HashSet<String> fullWords = new();
  private String? correctAnswer;

  private String resetButtonClass = "";
  private Dictionary<String, PlayerData> playerDataDictionary = new();

  protected override async Task OnInitializedAsync()
  {
    hubConnection = new HubConnectionBuilder()
      .WithUrl(NavigationManager.ToAbsoluteUri("/WordleOffHub"))
      .Build();
    hubConnection.Closed += async (e) => await OnClosed(e);

    hubConnection.On<Byte[]>("ServerFullWordsCompressed", async (compressedFullWordsBytes) => await StoreFullWords(compressedFullWordsBytes));
    hubConnection.On<Dictionary<String, PlayerData>>("ServerPlayerData", async (newPlayerDataDictionary) => await UpdatePlayerData(newPlayerDataDictionary));
    hubConnection.On<String>("ServerCurrentAnswer", (correctAnswer) => UpdateCurrentAnswer(correctAnswer));
    hubConnection.On<String>("ServerJoinFail", (message) => DisplayJoinFailMessage(message));
    
    await hubConnection.StartAsync();
  }

  #region Received from Server

  public async Task StoreFullWords(Byte[] compressedFullWordsBytes)
  {
    await Task.Run(() =>
    {
      MemoryStream input = new(compressedFullWordsBytes);
      MemoryStream output = new();
      using (DeflateStream dstream = new DeflateStream(input, CompressionMode.Decompress))
      {
        dstream.CopyTo(output);
      }
      Byte[] decompressedBytes = output.ToArray();
      String fullWordsString = UTF8Encoding.UTF8.GetString(decompressedBytes);
      fullWords = fullWordsString.Split("\n").ToHashSet();
    });    
  }

  public async Task UpdatePlayerData(Dictionary<String, PlayerData> newPlayerDataDictionary)
  {
    await Task.Run(()=>
    {
      sessionInitialized = true;
      playerDataDictionary = newPlayerDataDictionary;
      if (hubConnection is not null)
      {
        playerName = playerDataDictionary.First(x => x.Value.ConnectionId == hubConnection.ConnectionId).Key;
        UpdateCanSubmitNewGuess();
      }
      UpdateResetButtonClass();
      StateHasChanged();
    });
  }

  public void DisplayJoinFailMessage(String message) => joinErrorMessage = message;

  #endregion


  #region Send to Server

  public async Task JoinSession()
  {
    if (playerName.Length == 0)
    {
      joinErrorMessage = "You name cannot be empty!";
      return;
    }
    if (hubConnection is not null)
      await hubConnection.SendAsync("ClientConnectNew", SessionId, playerName);
  }

  public async Task UpdatePlayerName()
  {
    if (hubConnection is not null)
      await hubConnection.SendAsync("ClientUpdatePlayerName", playerName);
  }

  public async Task SubmitGuess()
  {
    if (hubConnection is not null && correctAnswer is not null)
    {
      if (guess.Length != correctAnswer!.Length)
      {
        submitError = $"Guess a {correctAnswer.Length}-letter word";
        return;
      }
      else if (!fullWords.Contains(guess.ToLower()))
      {
        submitError = "Not a word!";
        return;
      }
      if (canSubmitNewGuess)
        await hubConnection.SendAsync("ClientSubmitGuess", playerName, guess.ToLower());
      guess = "";
      submitError = "";
    }
  }

  public async Task Reconnect()
  {
    if (hubConnection is not null)
      await hubConnection.SendAsync("ClientReconnect", SessionId, playerName);
  }

  public void UpdateCurrentAnswer(String correctAnswer) => this.correctAnswer = correctAnswer;

  #endregion


  #region Other Client Code

  public async Task KeyDown(KeyboardEventArgs e)
  {
    PlayerData playerData = playerDataDictionary[playerName];
    if (correctAnswer is not null && playerData.PlayData.Count < 6 && !playerData.AnswerGuessCorrectly(correctAnswer) && canSubmitNewGuess)
    {
      if (e.Key == "Backspace" && guess.Length > 0)
      {
        guess = guess.Remove(guess.Length - 1);
      }
      else if (e.Key == "Enter")
      {
        if (guess.Length == correctAnswer.Length)
          await SubmitGuess();
      }
      else if (e.Key.Length == 1)
      {
        Char key = e.Key.ToLower()[0];
        if ('a' <= key && key <= 'z' && guess.Length < correctAnswer.Length)
          guess += key;
      }
    }
  }

  public Boolean IsConnected => hubConnection?.State == HubConnectionState.Connected;

  public Boolean IsGameInProgress => playerDataDictionary.Any(x => x.Value.PlayData.Count > 0);

  public void UpdateResetButtonClass()
  {
    if (correctAnswer is not null)
    {
      if (playerDataDictionary.Values.All(x => x.PlayData.Count == 6 || x.AnswerGuessCorrectly(correctAnswer)))
        resetButtonClass = "guess-correct";
      else if (playerDataDictionary.Values.All(x => x.PlayData.Count == 0))
        resetButtonClass = "guess-absent";
      else
        resetButtonClass = "guess-present";          
    }
    else
      resetButtonClass = "";
  }

  public void UpdateCanSubmitNewGuess() // Check if anyone's lagging behind me
  {
    Boolean behindOthers = false;
    Boolean alreadyGuessedCorrectly = false;
    Boolean guessLimitReached = false;
    Boolean keyExist = false;

    keyExist = playerDataDictionary.ContainsKey(playerName);
    if (keyExist && correctAnswer is not null)
    {
      if (playerDataDictionary[playerName].AnswerGuessCorrectly(correctAnswer))
        alreadyGuessedCorrectly = true;

      Int32 myGuessCount = playerDataDictionary[playerName].PlayData.Count;
      behindOthers = playerDataDictionary.Values.All((x) =>
      {
        return x.AnswerGuessCorrectly(correctAnswer)
                || x.PlayData.Count >= myGuessCount;
      });
      guessLimitReached = playerDataDictionary[playerName].PlayData.Count == 6;
    }        

    if (!behindOthers && keyExist)
      holdMessage = "Wait until everyone submit their guesses.";
    else if (alreadyGuessedCorrectly)
      holdMessage = "Correct!! Now you can see everyone else's guesses.";
    else if (!alreadyGuessedCorrectly && guessLimitReached)
      holdMessage = $"The answer is {correctAnswer?.ToUpper() ?? ""}";
    else
      holdMessage = "";
    canSubmitNewGuess = behindOthers && !alreadyGuessedCorrectly && !guessLimitReached;
  }

  private async Task NewGame()
  {
    if (!await jsRuntime.InvokeAsync<Boolean>("confirm", "Do you want to start a new game? This will reset everyone's progress"))
      return;
    if (hubConnection is not null)
      await hubConnection.SendAsync("ClientResetCurrentSession", SessionId);
  }

  private async Task OnClosed(Exception? e)
  {
    if (hubConnection is not null)
    {
      await hubConnection.StartAsync();
      await Reconnect();
    }
  }

  public async ValueTask DisposeAsync()
  {
    if (hubConnection is not null)
      await hubConnection.DisposeAsync();
  }

  #endregion


  #region RenderFragments

  private static RenderFragment<(String PlayerName, String Guess, String CorrectAnswer, Dictionary<String, PlayerData> PlayerDataDictionary)> RenderPlayerDataTable = data => __builder =>
  {
    String playerName = data.PlayerName;
    String guess = data.Guess;
    String correctAnswer = data.CorrectAnswer;
    Dictionary<String, PlayerData> playerDataDictionary = data.PlayerDataDictionary;
    if (playerDataDictionary.Count == 0)
      return;
    Int32 maxGuessesAmongPlayers = playerDataDictionary.Values.Max(x => x.PlayData.Count);
    Boolean allPlayersAtMaxGuesses = playerDataDictionary.Values.All(x => x.PlayData.Count == maxGuessesAmongPlayers || x.AnswerGuessCorrectly(correctAnswer));
    Boolean godMode = playerDataDictionary.ContainsKey(playerName) ? playerDataDictionary[playerName].AnswerGuessCorrectly(correctAnswer) && allPlayersAtMaxGuesses: false;

    Int32 maxIndex = playerDataDictionary.Count == 0 ? -1 : playerDataDictionary.Max(x => x.Value.Index);
    List<KeyValuePair<String, PlayerData>?> orderedList = new();
    for (Int32 i = 1; i <= maxIndex; ++i)
    {
      var matchingPlayers = playerDataDictionary.Where(x => x.Value.Index == i);
      if (matchingPlayers.Count() > 0)
        orderedList.Add(matchingPlayers.First());
    }
    <table>
      <tr>
        @for (Int32 i = 0; i < orderedList.Count; ++i)
        {
          var pairValue = orderedList[i]!.Value;
          var currentPlayerName = pairValue.Key;
          var currentPlayerData = pairValue.Value;
          Boolean isCurrentPlayerLocal = playerName == currentPlayerName;
          Int32 emptyRowOffset = 0;
          if (isCurrentPlayerLocal)
            emptyRowOffset = 1;
          String youIndicator = (playerName == currentPlayerName) ? " (You)" : "";
          <td>
            <div class="play-container">
              <div>@($"{currentPlayerName}{youIndicator}")</div>
              <div class="guess-board">
                @for (Int32 j = 0; j < currentPlayerData.PlayData.Count; ++j)
                {
                  String currentGuess = currentPlayerData.PlayData[j];
                  @if (j == maxGuessesAmongPlayers - 1 && !allPlayersAtMaxGuesses)
                    @RenderTempGuessRow!((playerName, currentPlayerName, currentGuess))
                  else
                    @RenderGuessRow!((correctAnswer, currentGuess, !isCurrentPlayerLocal && !godMode))
                }
                @if (currentPlayerData.PlayData.Count < 6 && isCurrentPlayerLocal)
                {
                  @RenderGuessingRow!((correctAnswer, guess))
                }
                @for (Int32 j = currentPlayerData.PlayData.Count + emptyRowOffset; j < 6; ++j)
                {
                  @RenderEmptyRow!(correctAnswer)
                }
              </div>
            </div>              
          </td>
        }
      </tr>
    </table>
  };

  private static RenderFragment<(String CorrectAnswer, String Guess, Boolean HideLetters)> RenderGuessRow = data => __builder =>
  {
    String correctAnswer = data.CorrectAnswer;
    String guess = data.Guess;
    Boolean hideLetters = data.HideLetters;
    
    StringBuilder sb = new StringBuilder();
    Dictionary<Char, Int32> letterCountInAnswer = new();
    for (Int32 i = 0; i < correctAnswer.Length; ++i)
    {
      sb.Append('0');
      if (letterCountInAnswer.ContainsKey(correctAnswer[i]))
        ++letterCountInAnswer[correctAnswer[i]];
      else
        letterCountInAnswer.Add(correctAnswer[i], 1);
    }
    Char[] backgroundColors = sb.ToString().ToCharArray();
    for (Int32 i = 0; i < correctAnswer.Length; ++i)
      if (guess[i] == correctAnswer[i])
      {
        backgroundColors[i] = '2';
        --letterCountInAnswer[guess[i]];
      }
    for (Int32 i = 0; i < correctAnswer.Length; ++i)
      if (correctAnswer.Contains(guess[i]) && letterCountInAnswer[guess[i]] > 0)
      {
        backgroundColors[i] = '1';
        --letterCountInAnswer[guess[i]];
      }
    <div class="guess-row">
      @for (Int32 i = 0; i < correctAnswer.Length; ++i)
      {
        Char displayChar = hideLetters ? '?' : guess[i];
        String backgroundColorCSS = "";
        @switch (backgroundColors[i])
        {
          case '0':
            backgroundColorCSS = "guess-absent";
            break;
          case '1':
            backgroundColorCSS = "guess-present";
            break;
          case '2':
            backgroundColorCSS = "guess-correct";
            break;
        }
        <div class=@($"guess-tile {backgroundColorCSS}")>@displayChar</div>
      }
    </div>
  };

  private static RenderFragment<(String PlayerName, String CurrentPlayerName, String Guess)> RenderTempGuessRow = data => __builder =>
  {
    String playerName = data.PlayerName;
    String currentPlayerName = data.CurrentPlayerName;
    String guess = data.Guess;

    <div class="guess-row">
      @if (playerName == currentPlayerName)
      {
        @for (Int32 k = 0; k < guess.Length; ++k)
        {
          <div class="guess-tile guess-guessing">@guess[k]</div>
        }
      }
      else
      {
        @for (Int32 k = 0; k < guess.Length; ++k)
        {
          <div class="guess-tile guess-guessing">?</div>
        }
      }
    </div>
  };

  private static RenderFragment<String> RenderEmptyRow = correctAnswer => __builder =>
  {
    <div class="guess-row">
      @for (Int32 k = 0; k < correctAnswer.Length; ++k)
      {
        <div class="guess-tile guess-empty"></div>
      }
    </div>
  };

  private static RenderFragment<(String CorrectAnswer, String Guess)> RenderGuessingRow = data => __builder =>
  {
    String correctAnswer = data.CorrectAnswer;
    String guess = data.Guess;
    <div class="guess-row">
      @for (Int32 i = 0; i < guess.Length; ++i)
      {
        <div class=@($"guess-tile guess-guessing")>@guess[i]</div>
      }
      @for (Int32 i = guess.Length; i < correctAnswer.Length; ++i)
      {
        <div class="guess-tile guess-empty"></div>
      }
    </div>
  };

  #endregion
}
